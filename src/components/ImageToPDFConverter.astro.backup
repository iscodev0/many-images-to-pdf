---
import Button from './ui/Button.astro';
import Card from './ui/Card.astro';
import Table from './ui/Table.astro';
import DropZone from './ui/DropZone.astro';
import SettingsModal from './ui/SettingsModal.astro';
import { Upload, Link, RotateCcw, Download, Trash2, Settings } from 'lucide-astro';
import { Image as ImageIcon } from 'lucide-astro';
---

<div class="w-full max-w-7xl mx-auto p-6 space-y-8">
  <!-- Header -->
  <div class="text-center space-y-4">
    <div class="flex items-center justify-center space-x-4">
      <div class="w-16 h-16 rounded-full bg-gradient-to-br from-green-500 to-blue-600 flex items-center justify-center">
        <img src="/logo.webp" alt="PandaScan Logo" class="w-12 h-12" onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';" />
        <div class="w-8 h-8 text-white font-bold text-2xl hidden items-center justify-center">üêº</div>
      </div>
      <div>
        <h1 class="text-4xl font-bold tracking-tight bg-gradient-to-r from-green-600 to-blue-600 bg-clip-text text-transparent">
          PandaScan Converter
        </h1>
        <p class="text-sm text-muted-foreground">powered by iscodev </p>
      </div>
    </div>
    <p class="text-xl text-muted-foreground max-w-2xl mx-auto text-center">
      Transform your images into professional PDFs with our advanced converter. Perfect for comics, documents, and collections.
    </p>
  </div>

  <!-- Mini Tutorial Section -->
  <Card class="p-6 bg-gradient-to-r from-blue-50 to-green-50 border-blue-200">
    <div class="space-y-4">
      <h3 class="text-lg font-semibold text-center">üöÄ How to Use / C√≥mo Usar</h3>
      
      <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
        <!-- English Tutorial -->
        <div class="space-y-3">
          <h4 class="font-medium text-blue-700">üá∫üá∏ English</h4>
          <ol class="text-sm text-muted-foreground space-y-2">
            <li><strong>1.</strong> Upload images by dragging files or adding URLs</li>
            <li><strong>2.</strong> Reorder by dragging rows in the table</li>
            <li><strong>3.</strong> Configure settings (quality, comic style, etc.)</li>
            <li><strong>4.</strong> Download your professional PDF</li>
          </ol>
          <p class="text-xs text-blue-600"><strong>Perfect for:</strong> Comics, documents, photo collections</p>
        </div>
        
        <!-- Spanish Tutorial -->
        <div class="space-y-3">
          <h4 class="font-medium text-green-700">üá™üá∏ Espa√±ol</h4>
          <ol class="text-sm text-muted-foreground space-y-2">
            <li><strong>1.</strong> Sube im√°genes arrastrando archivos o agregando URLs</li>
            <li><strong>2.</strong> Reordena arrastrando filas en la tabla</li>
            <li><strong>3.</strong> Configura ajustes (calidad, estilo c√≥mic, etc.)</li>
            <li><strong>4.</strong> Descarga tu PDF profesional</li>
          </ol>
          <p class="text-xs text-green-600"><strong>Perfecto para:</strong> C√≥mics, documentos, colecciones de fotos</p>
        </div>
      </div>
    </div>
  </Card>

  <!-- Upload Section -->
  <Card class="p-8">
    <div class="space-y-6">
      <h2 class="text-2xl font-semibold flex items-center space-x-2">
        <Upload class="w-6 h-6 text-primary" />
        <span>Add Images</span>
      </h2>
      
      <div class="grid grid-cols-1 lg:grid-cols-2 gap-8">
        <!-- File Upload -->
        <div class="space-y-4">
          <label class="text-sm font-medium text-muted-foreground uppercase tracking-wide">Upload from Device</label>
          <DropZone />
        </div>

        <!-- URL Input -->
        <div class="space-y-4">
          <label class="text-sm font-medium text-muted-foreground uppercase tracking-wide">Add from URL</label>
          <div class="space-y-3">
            <div class="flex space-x-3">
              <input 
                type="url" 
                id="url-input"
                placeholder="https://example.com/image.jpg"
                class="flex-1 px-4 py-3 border border-input rounded-lg bg-background text-sm ring-offset-background placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 transition-all"
              />
              <Button id="add-url-btn" size="lg" class="px-6">
                <Link class="w-4 h-4 mr-2" />
                Add URL
              </Button>
            </div>
            <p class="text-xs text-muted-foreground">
              Supports direct image URLs (JPG, PNG, JPEG, WebP)
            </p>
          </div>
        </div>
      </div>
    </div>
  </Card>

  <!-- Controls -->
  <div class="flex flex-wrap gap-3 justify-center">
    <Button id="settings-btn" variant="outline" size="lg" class="min-w-[120px]">
      <Settings class="w-4 h-4 mr-2" />
      Settings
    </Button>
    <Button id="reverse-order-btn" variant="outline" size="lg" class="min-w-[140px]">
      <RotateCcw class="w-4 h-4 mr-2" />
      Reverse Order
    </Button>
    <Button id="clear-all-btn" variant="destructive" size="lg" class="min-w-[120px]">
      <Trash2 class="w-4 h-4 mr-2" />
      Clear All
    </Button>
    <Button id="download-pdf-btn" size="lg" class="bg-gradient-to-r from-green-600 to-green-700 hover:from-green-700 hover:to-green-800 min-w-[160px]">
      <Download class="w-4 h-4 mr-2" />
      Download PDF
    </Button>
  </div>

  <!-- Images Preview -->
  <Card class="p-8">
    <div class="space-y-6">
      <div class="flex items-center justify-between">
        <h2 class="text-2xl font-semibold flex items-center space-x-2">
          <ImageIcon class="w-6 h-6 text-primary" />
          <span>Images Preview</span>
        </h2>
        <div id="image-count" class="text-sm text-muted-foreground">
          0 images
        </div>
      </div>
      
      <div class="relative w-full overflow-hidden rounded-lg border">
        <div class="overflow-x-auto">
          <table class="w-full">
            <thead class="bg-muted/50">
              <tr>
                <th class="h-14 px-6 text-left align-middle font-semibold text-muted-foreground text-sm uppercase tracking-wide">Preview</th>
                <th class="h-14 px-6 text-left align-middle font-semibold text-muted-foreground text-sm uppercase tracking-wide">Name</th>
                <th class="h-14 px-6 text-left align-middle font-semibold text-muted-foreground text-sm uppercase tracking-wide">Source</th>
                <th class="h-14 px-6 text-left align-middle font-semibold text-muted-foreground text-sm uppercase tracking-wide">Size</th>
                <th class="h-14 px-6 text-left align-middle font-semibold text-muted-foreground text-sm uppercase tracking-wide">Quality</th>
                <th class="h-14 px-6 text-left align-middle font-semibold text-muted-foreground text-sm uppercase tracking-wide">Actions</th>
              </tr>
            </thead>
            <tbody id="images-tbody" class="sortable">
              <!-- Images will be populated here by JavaScript -->
            </tbody>
          </table>
        </div>
        
        <div id="empty-state" class="text-center py-16">
          <div class="w-20 h-20 mx-auto rounded-full bg-muted/30 flex items-center justify-center mb-6">
            <ImageIcon class="w-10 h-10 text-muted-foreground/50" />
          </div>
          <h3 class="text-lg font-medium text-muted-foreground mb-2">No images added yet</h3>
          <p class="text-sm text-muted-foreground mb-6 max-w-md mx-auto">
            Upload files from your device or add images from URLs to get started creating your PDF
          </p>
          <Button variant="outline" onclick="document.getElementById('file-upload').click()">
            <Upload class="w-4 h-4 mr-2" />
            Add Your First Image
          </Button>
        </div>
      </div>
    </div>
  </Card>
  
  <!-- Settings Modal -->
  <SettingsModal />
</div>

<script>
  import imageCompression from 'browser-image-compression';
  import jsPDF from 'jspdf';

  // Utility classes embedded directly
  class ImageProcessor {
    static async compressImage(file, quality) {
      const options = {
        maxSizeMB: quality === 'sd' ? 0.5 : 2,
        maxWidthOrHeight: quality === 'sd' ? 800 : 1920,
        useWebWorker: true,
        fileType: 'image/jpeg',
      };

      try {
        const compressedFile = await imageCompression(file, options);
        return compressedFile;
      } catch (error) {
        console.error('Error compressing image:', error);
        return file;
      }
    }

    static async createImageFromUrl(url) {
      try {
        const response = await fetch(url);
        if (!response.ok) throw new Error('Failed to fetch image');
        
        const blob = await response.blob();
        const filename = url.split('/').pop() || 'image.jpg';
        return new File([blob], filename, { type: blob.type });
      } catch (error) {
        console.error('Error creating image from URL:', error);
        throw error;
      }
    }

    static createPreviewUrl(file) {
      return URL.createObjectURL(file);
    }

    static generateId() {
      return Math.random().toString(36).substr(2, 9);
    }

    static async processImageItem(file, type, quality = 'hd') {
      const id = this.generateId();
      const preview = this.createPreviewUrl(file);
      
      const compressedFile = await this.compressImage(file, quality);

      return {
        id,
        file: type === 'local' ? file : undefined,
        url: type === 'url' ? preview : undefined,
        preview,
        name: file.name,
        size: file.size,
        type,
        originalFile: file,
        compressedFile,
        quality,
      };
    }

    static revokePreviewUrl(url) {
      URL.revokeObjectURL(url);
    }
  }

  class PDFGenerator {
    static async generatePDF(images, settings = {}) {
      // Check if comic style is enabled (now from pageFormat)
      const isComicStyle = settings.pageFormat === 'comic' || settings.outputQuality === 'comic';
      
      if (isComicStyle) {
        return this.generateComicStylePDF(images, settings);
      } else {
        return this.generateStandardPDF(images, settings);
      }
    }

    static async generateComicStylePDF(images, settings = {}) {
      const config = {
        pageWidth: settings.comicWidth || 480,
        pageHeight: settings.comicHeight || 3000,
        imageQuality: settings.comicImageQuality || 0.85,
        pdfQuality: settings.pdfQuality || 'MEDIUM',
        includeWatermark: settings.includeWatermark !== false,
        includeMetadata: settings.includeMetadata !== false,
        includePageNumbers: settings.includePageNumbers !== false,
        ...settings
      };

      const pdf = new jsPDF({
        unit: 'pt',
        format: [config.pageWidth, config.pageHeight]
      });

      pdf.deletePage(1);
      pdf.addPage();
      let currentY = 0;

      // Watermark function for comic style
      const addWatermark = (doc) => {
        if (!config.includeWatermark) return;
        
        const text = 'Generated with pandascan.online';
        const fontSize = config.pageWidth < 500 ? 18 : 24;
        const opacity = 0.4;
        const margin = 20;
        
        doc.saveGraphicsState();
        doc.setGState(new (doc as any).GState({ 'opacity': opacity }));
        doc.setFont("helvetica", "bold");
        doc.setFontSize(fontSize);
        doc.setTextColor(150, 150, 150);
        doc.text(text, margin, 20);
        doc.text(text, margin, config.pageHeight - 20);
        doc.restoreGraphicsState();
      };

      // Add header if metadata is enabled
      if (config.includeMetadata) {
        pdf.setFontSize(16);
        pdf.setTextColor(60, 60, 60);
        pdf.text('Image Collection', 20, 20);
        
        pdf.setFontSize(10);
        pdf.setTextColor(120, 120, 120);
        const date = new Date().toLocaleDateString();
        pdf.text(`Generated on ${date} - ${images.length} images`, 20, 35);
        
        currentY = 50;
      }

      for (let i = 0; i < images.length; i++) {
        const imageItem = images[i];
        
        try {
          const file = imageItem.compressedFile || imageItem.originalFile;
          if (!file) continue;

          const imageDataUrl = await this.fileToDataUrl(file);
          const imgDimensions = await this.getImageDimensions(imageDataUrl);
          
          // Resize image to fit comic style
          const resizedCanvas = document.createElement('canvas');
          const targetWidth = config.pageWidth;
          const aspectRatio = imgDimensions.height / imgDimensions.width;
          resizedCanvas.width = targetWidth;
          resizedCanvas.height = targetWidth * aspectRatio;
          
          const ctx = resizedCanvas.getContext('2d');
          if (!ctx) continue;
          
          ctx.imageSmoothingEnabled = true;
          ctx.imageSmoothingQuality = 'high';
          ctx.drawImage(await this.createImageFromDataUrl(imageDataUrl), 0, 0, resizedCanvas.width, resizedCanvas.height);

          const { width: sourceWidth, height: sourceHeight } = resizedCanvas;
          let remainingImageHeight = sourceHeight;
          let sourceImageY = 0;

          while (remainingImageHeight > 0) {
            if (currentY >= config.pageHeight) {
              addWatermark(pdf);
              pdf.addPage();
              currentY = 0;
            }

            const spaceOnPage = config.pageHeight - currentY;
            const heightToDrawOnPage = Math.min(remainingImageHeight, spaceOnPage);

            // Create slice canvas
            const sliceCanvas = document.createElement('canvas');
            sliceCanvas.width = sourceWidth;
            sliceCanvas.height = heightToDrawOnPage;
            const sliceCtx = sliceCanvas.getContext('2d');

            if (sliceCtx) {
              sliceCtx.imageSmoothingEnabled = true;
              sliceCtx.imageSmoothingQuality = 'high';
              sliceCtx.drawImage(resizedCanvas, 0, sourceImageY, sourceWidth, heightToDrawOnPage, 0, 0, sourceWidth, heightToDrawOnPage);
              
              const imageData = sliceCanvas.toDataURL('image/jpeg', config.imageQuality);
              
              try {
                pdf.addImage(imageData, 'JPEG', 0, currentY, sourceWidth, heightToDrawOnPage);
              } catch (e) {
                console.error("Error adding image as JPEG, falling back to PNG.", e);
                const pngData = sliceCanvas.toDataURL('image/png');
                pdf.addImage(pngData, 'PNG', 0, currentY, sourceWidth, heightToDrawOnPage);
              }
            }

            currentY += heightToDrawOnPage;
            remainingImageHeight -= heightToDrawOnPage;
            sourceImageY += heightToDrawOnPage;
          }

        } catch (error) {
          console.error('Error adding image to PDF:', error);
        }
      }

      addWatermark(pdf);
      
      // Download with comic label
      const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, '-');
      const filename = `images-comic-style-${timestamp}.pdf`;
      pdf.save(filename);
      
      this.showSuccessMessage(images.length, filename);
    }

    static async generateStandardPDF(images, settings = {}) {
      // Page format dimensions (in mm)
      const formats = {
        a4: { width: 210, height: 297 },
        letter: { width: 216, height: 279 },
        legal: { width: 216, height: 356 }
      };

      const pageFormat = formats[settings.pageFormat] || formats.a4;
      const orientation = settings.orientation || 'portrait';
      
      const config = {
        quality: settings.quality || 'hd',
        pageWidth: orientation === 'portrait' ? pageFormat.width : pageFormat.height,
        pageHeight: orientation === 'portrait' ? pageFormat.height : pageFormat.width,
        margin: settings.marginVertical || 15,
        marginHorizontal: settings.marginHorizontal || 15,
        imageSpacing: settings.imageSpacing || 10,
        pdfQuality: settings.pdfQuality || 'MEDIUM',
        includeMetadata: settings.includeMetadata !== false,
        includePageNumbers: settings.includePageNumbers !== false,
        includeWatermark: settings.includeWatermark !== false,
        maxImagesPerPage: 6,
        ...settings
      };

      const pdf = new jsPDF({
        orientation: orientation,
        unit: 'mm',
        format: settings.pageFormat || 'a4',
      });

      let isFirstPage = true;
      let currentPageHeight = config.margin;
      const maxPageHeight = config.pageHeight - config.margin;
      const contentWidth = config.pageWidth - (config.margin + config.marginHorizontal);
      const maxImageWidth = contentWidth;
      const maxImageHeight = (maxPageHeight - config.margin) / 3;

      // Watermark function for standard style
      const addWatermark = (doc) => {
        if (!config.includeWatermark) return;
        
        const text = 'Generated with pandascan.online';
        const fontSize = 12;
        const opacity = 0.4;
        
        doc.saveGraphicsState();
        doc.setGState(new (doc as any).GState({ 'opacity': opacity }));
        doc.setFont("helvetica", "bold");
        doc.setFontSize(fontSize);
        doc.setTextColor(150, 150, 150);
        doc.text(text, config.margin, config.margin);
        doc.text(text, config.margin, config.pageHeight - 10);
        doc.restoreGraphicsState();
      };

      // Add header to first page
      if (images.length > 0 && config.includeMetadata) {
        pdf.setFontSize(16);
        pdf.setTextColor(60, 60, 60);
        pdf.text('Image Collection', config.margin, config.margin);
        
        pdf.setFontSize(10);
        pdf.setTextColor(120, 120, 120);
        const date = new Date().toLocaleDateString();
        pdf.text(`Generated on ${date} - ${images.length} images`, config.margin, config.margin + 8);
        
        currentPageHeight = config.margin + 20;
      }

      for (let i = 0; i < images.length; i++) {
        const imageItem = images[i];
        
        try {
          const file = imageItem.compressedFile || imageItem.originalFile;
          if (!file) continue;

          const imageDataUrl = await this.fileToDataUrl(file);
          const imgDimensions = await this.getImageDimensions(imageDataUrl);
          
          // Calculate optimal dimensions
          let scaledWidth = imgDimensions.width;
          let scaledHeight = imgDimensions.height;
          
          const widthScale = maxImageWidth / imgDimensions.width;
          const heightScale = maxImageHeight / imgDimensions.height;
          const scale = Math.min(widthScale, heightScale, 1);
          
          scaledWidth = imgDimensions.width * scale;
          scaledHeight = imgDimensions.height * scale;

          // Check if we need a new page
          const spaceNeeded = scaledHeight + (config.includeMetadata ? 8 : 0) + config.imageSpacing;
          if (!isFirstPage && (currentPageHeight + spaceNeeded) > maxPageHeight) {
            addWatermark(pdf);
            pdf.addPage();
            currentPageHeight = config.margin;
          }

          // Center the image horizontally
          const xPosition = config.margin + (contentWidth - scaledWidth) / 2;

          // Add image to PDF
          pdf.addImage(
            imageDataUrl,
            'JPEG',
            xPosition,
            currentPageHeight,
            scaledWidth,
            scaledHeight,
            undefined,
            config.pdfQuality
          );

          // Add image info if enabled
          if (config.includeMetadata) {
            pdf.setFontSize(8);
            pdf.setTextColor(100, 100, 100);
            const infoY = currentPageHeight + scaledHeight + 3;
            pdf.text(
              `${i + 1}. ${imageItem.name} (${imageItem.quality.toUpperCase()})`,
              config.margin,
              infoY
            );
            currentPageHeight += scaledHeight + config.imageSpacing + 5;
          } else {
            currentPageHeight += scaledHeight + config.imageSpacing;
          }

          isFirstPage = false;

        } catch (error) {
          console.error('Error adding image to PDF:', error);
        }
      }

      // Add final watermark and page numbers
      addWatermark(pdf);
      
      // Add page numbers if enabled
      if (config.includePageNumbers) {
        const totalPages = pdf.internal.getNumberOfPages();
        for (let i = 1; i <= totalPages; i++) {
          pdf.setPage(i);
          pdf.setFontSize(8);
          pdf.setTextColor(150, 150, 150);
          pdf.text(
            `Page ${i} of ${totalPages}`,
            config.pageWidth - config.marginHorizontal - 25,
            config.pageHeight - 5
          );
        }
      }

      // Download the PDF
      const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, '-');
      const qualityLabel = settings.outputQuality === 'sd' ? 'SD' : 'HD';
      const filename = `images-${qualityLabel}-${timestamp}.pdf`;
      pdf.save(filename);
      
      // Show success message
      this.showSuccessMessage(images.length, filename);
    }

    static createImageFromDataUrl(dataUrl) {
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.onload = () => resolve(img);
        img.onerror = reject;
        img.src = dataUrl;
      });
    }

    static showSuccessMessage(imageCount, filename) {
      // Create a temporary success notification
      const notification = document.createElement('div');
      notification.className = 'fixed top-4 right-4 bg-green-600 text-white px-6 py-3 rounded-lg shadow-lg z-50 transition-all duration-300 transform translate-x-full';
      notification.innerHTML = `
        <div class="flex items-center space-x-2">
          <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path>
          </svg>
          <div>
            <p class="font-medium">PDF Generated Successfully!</p>
            <p class="text-sm opacity-90">${imageCount} images ‚Üí ${filename}</p>
          </div>
        </div>
      `;
      
      document.body.appendChild(notification);
      
      // Animate in
      setTimeout(() => {
        notification.classList.remove('translate-x-full');
      }, 100);
      
      // Remove after 5 seconds
      setTimeout(() => {
        notification.classList.add('translate-x-full');
        setTimeout(() => {
          document.body.removeChild(notification);
        }, 300);
      }, 5000);
    }

    static fileToDataUrl(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => resolve(reader.result);
        reader.onerror = reject;
        reader.readAsDataURL(file);
      });
    }

    static getImageDimensions(dataUrl) {
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.onload = () => resolve({ width: img.width, height: img.height });
        img.onerror = reject;
        img.src = dataUrl;
      });
    }
  }

  class ImageManager {
    constructor() {
      this.images = [];
      this.currentQuality = 'hd';
      this.initializeEventListeners();
      this.updateUI();
    }

    getCurrentQuality() {
      // Get quality from settings modal (priority)
      const settings = (window as any).pdfSettings;
      if (settings && settings.outputQuality) {
        return settings.outputQuality;
      }
      
      // Fallback to default
      return this.currentQuality;
    }

    initializeEventListeners() {
      // File upload
      const fileInput = document.getElementById('file-upload');
      fileInput.addEventListener('change', this.handleFileUpload.bind(this));

      // URL input
      const urlInput = document.getElementById('url-input');
      const addUrlBtn = document.getElementById('add-url-btn');
      addUrlBtn.addEventListener('click', this.handleUrlAdd.bind(this));
      urlInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') this.handleUrlAdd();
      });

      // Control buttons
      document.getElementById('settings-btn')?.addEventListener('click', () => {
        if (typeof window.openSettingsModal === 'function') {
          window.openSettingsModal();
        }
      });
      document.getElementById('reverse-order-btn')?.addEventListener('click', this.reverseOrder.bind(this));
      document.getElementById('clear-all-btn')?.addEventListener('click', this.clearAll.bind(this));
      document.getElementById('download-pdf-btn')?.addEventListener('click', this.downloadPDF.bind(this));

      // Drag and drop
      this.initializeDragAndDrop();
    }

    async handleFileUpload(event) {
      const input = event.target;
      const files = input.files;
      if (!files) return;

      for (const file of Array.from(files)) {
        try {
          const imageItem = await ImageProcessor.processImageItem(file, 'local', this.getCurrentQuality());
          this.images.push(imageItem);
        } catch (error) {
          console.error('Error processing file:', error);
        }
      }

      this.updateUI();
      input.value = ''; // Reset input
    }

    async handleUrlAdd() {
      const urlInput = document.getElementById('url-input');
      const url = urlInput.value.trim();
      
      if (!url) return;

      try {
        const file = await ImageProcessor.createImageFromUrl(url);
        const imageItem = await ImageProcessor.processImageItem(file, 'url', this.getCurrentQuality());
        imageItem.url = url; // Keep original URL
        this.images.push(imageItem);
        this.updateUI();
        urlInput.value = ''; // Clear input
      } catch (error) {
        console.error('Error adding image from URL:', error);
        alert('Failed to load image from URL. Please check the URL and try again.');
      }
    }

    async updateAllImageQuality() {
      for (const image of this.images) {
        if (image.originalFile) {
          image.quality = this.getCurrentQuality();
          image.compressedFile = await ImageProcessor.compressImage(image.originalFile, this.getCurrentQuality());
        }
      }
      this.updateUI();
    }

    reverseOrder() {
      this.images.reverse();
      this.updateUI();
    }

    clearAll() {
      // Revoke object URLs to free memory
      this.images.forEach(image => {
        if (image.preview) {
          ImageProcessor.revokePreviewUrl(image.preview);
        }
      });
      this.images = [];
      this.updateUI();
    }

    async downloadPDF() {
      if (this.images.length === 0) {
        alert('Please add some images first');
        return;
      }

      try {
        // Get settings from modal or use defaults
        const userSettings = window.pdfSettings || {};
        const settings = {
          quality: this.getCurrentQuality(),
          ...userSettings
        };
        
        await PDFGenerator.generatePDF(this.images, settings);
      } catch (error) {
        console.error('Error generating PDF:', error);
        alert('Failed to generate PDF. Please try again.');
      }
    }

    removeImage(id) {
      const index = this.images.findIndex(img => img.id === id);
      if (index !== -1) {
        const image = this.images[index];
        if (image.preview) {
          ImageProcessor.revokePreviewUrl(image.preview);
        }
        this.images.splice(index, 1);
        this.updateUI();
      }
    }

    updateUI() {
      const tbody = document.getElementById('images-tbody');
      const emptyState = document.getElementById('empty-state');
      const imageCount = document.getElementById('image-count');

      // Update counter
      const count = this.images.length;
      imageCount.textContent = `${count} image${count !== 1 ? 's' : ''}`;

      if (this.images.length === 0) {
        tbody.innerHTML = '';
        emptyState.style.display = 'block';
        return;
      }

      emptyState.style.display = 'none';
      
      tbody.innerHTML = this.images.map((image, index) => `
        <tr class="border-b transition-colors hover:bg-muted/50 cursor-move group" data-id="${image.id}">
          <td class="p-6 align-middle">
            <div class="relative">
              <img src="${image.preview}" alt="${image.name}" class="w-20 h-20 object-cover rounded-lg border-2 border-border group-hover:border-primary/50 transition-colors" />
              <div class="absolute -top-2 -right-2 w-6 h-6 bg-primary/10 rounded-full flex items-center justify-center text-xs font-medium text-primary">
                ${index + 1}
              </div>
            </div>
          </td>
          <td class="p-6 align-middle">
            <div class="space-y-1">
              <p class="font-medium text-sm truncate max-w-[200px]" title="${image.name}">${image.name}</p>
              <p class="text-xs text-muted-foreground">
                ${image.size ? this.formatFileSize(image.size) : 'Size unknown'}
              </p>
            </div>
          </td>
          <td class="p-6 align-middle">
            <span class="inline-flex items-center rounded-full px-3 py-1 text-xs font-medium ${
              image.type === 'local' 
                ? 'bg-blue-100 text-blue-800 dark:bg-blue-900/20 dark:text-blue-400' 
                : 'bg-green-100 text-green-800 dark:bg-green-900/20 dark:text-green-400'
            }">
              ${image.type === 'local' ? 'üìÅ Local File' : 'üåê URL'}
            </span>
          </td>
          <td class="p-6 align-middle text-muted-foreground">
            ${image.size ? this.formatFileSize(image.size) : 'Unknown'}
          </td>
          <td class="p-6 align-middle">
            <span class="inline-flex items-center rounded-full px-3 py-1 text-xs font-medium ${
              image.quality === 'hd' 
                ? 'bg-purple-100 text-purple-800 dark:bg-purple-900/20 dark:text-purple-400' 
                : 'bg-orange-100 text-orange-800 dark:bg-orange-900/20 dark:text-orange-400'
            }">
              ${image.quality === 'hd' ? 'üéØ HD Quality' : '‚ö° SD Quality'}
            </span>
          </td>
          <td class="p-6 align-middle">
            <div class="flex items-center space-x-2">
              <button 
                onclick="imageManager.removeImage('${image.id}')"
                class="inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 hover:bg-destructive/10 hover:text-destructive h-9 w-9"
                title="Remove image"
              >
                <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />
                </svg>
              </button>
              <div class="w-6 h-6 text-muted-foreground/50 cursor-move" title="Drag to reorder">
                <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16V4m0 0L3 8m4-4l4 4m6 0v12m0 0l4-4m-4 4l-4-4" />
                </svg>
              </div>
            </div>
          </td>
        </tr>
      `).join('');

      // Re-initialize drag and drop for new elements
      this.initializeDragAndDrop();
    }

    formatFileSize(bytes) {
      if (bytes === 0) return '0 Bytes';
      const k = 1024;
      const sizes = ['Bytes', 'KB', 'MB', 'GB'];
      const i = Math.floor(Math.log(bytes) / Math.log(k));
      return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
    }

    initializeDragAndDrop() {
      const tbody = document.getElementById('images-tbody');
      if (!tbody) return;

      let draggedElement = null;
      let draggedIndex = -1;
      
      // Remove any existing listeners to prevent duplicates
      const newTbody = tbody.cloneNode(true);
      tbody.parentNode?.replaceChild(newTbody, tbody);
      
      // Get fresh reference
      const freshTbody = document.getElementById('images-tbody');
      if (!freshTbody) return;

      // Add styles only once
      if (!document.getElementById('simple-drag-styles')) {
        const style = document.createElement('style');
        style.id = 'simple-drag-styles';
        style.textContent = `
          .dragging {
            opacity: 0.4;
            background: #f0f9ff;
          }
          .drag-over {
            border-top: 3px solid #3b82f6;
          }
          .drag-over-bottom {
            border-bottom: 3px solid #3b82f6;
          }
          tr[draggable="true"] {
            cursor: grab;
          }
          tr[draggable="true"]:active {
            cursor: grabbing;
          }
        `;
        document.head.appendChild(style);
      }

      freshTbody.addEventListener('dragstart', (e) => {
        draggedElement = (e.target as HTMLElement).closest('tr');
        if (draggedElement) {
          draggedIndex = Array.from(freshTbody.children).indexOf(draggedElement);
          draggedElement.classList.add('dragging');
          e.dataTransfer!.effectAllowed = 'move';
        }
      });

      freshTbody.addEventListener('dragend', (e) => {
        if (draggedElement) {
          draggedElement.classList.remove('dragging');
          draggedElement = null;
          draggedIndex = -1;
        }
        // Clean up all drag classes
        freshTbody.querySelectorAll('.drag-over, .drag-over-bottom').forEach(el => {
          el.classList.remove('drag-over', 'drag-over-bottom');
        });
      });

      freshTbody.addEventListener('dragover', (e) => {
        e.preventDefault();
        if (!draggedElement) return;
        
        const target = (e.target as HTMLElement).closest('tr');
        if (!target || target === draggedElement) return;
        
        // Clean previous indicators
        freshTbody.querySelectorAll('.drag-over, .drag-over-bottom').forEach(el => {
          el.classList.remove('drag-over', 'drag-over-bottom');
        });
        
        // Determine if we should insert before or after
        const rect = target.getBoundingClientRect();
        const middle = rect.top + rect.height / 2;
        
        if (e.clientY < middle) {
          target.classList.add('drag-over');
        } else {
          target.classList.add('drag-over-bottom');
        }
      });

      freshTbody.addEventListener('drop', (e) => {
        e.preventDefault();
        if (!draggedElement) return;
        
        const target = (e.target as HTMLElement).closest('tr');
        if (!target || target === draggedElement) return;
        
        const targetIndex = Array.from(freshTbody.children).indexOf(target);
        const rect = target.getBoundingClientRect();
        const middle = rect.top + rect.height / 2;
        
        // Determine final index
        let finalIndex = targetIndex;
        if (e.clientY >= middle) {
          finalIndex = targetIndex + 1;
        }
        
        // Adjust for drag direction
        if (draggedIndex < finalIndex) {
          finalIndex--;
        }
        
        // Perform the reorder
        if (draggedIndex !== finalIndex && draggedIndex !== -1) {
          this.performReorder(draggedIndex, finalIndex);
        }
      });

      // Make all rows draggable
      this.updateDraggableRows();
    }

    updateDraggableRows() {
      const tbody = document.getElementById('images-tbody');
      if (!tbody) return;
      
      const rows = tbody.querySelectorAll('tr');
      rows.forEach(row => {
        row.setAttribute('draggable', 'true');
      });
    }

    performReorder(fromIndex, toIndex) {
      if (fromIndex === toIndex || fromIndex < 0 || toIndex < 0) return;
      
      // Reorder in the data array
      const [movedItem] = this.images.splice(fromIndex, 1);
      this.images.splice(toIndex, 0, movedItem);
      
      // Update UI
      this.updateUI();
      
      // Re-initialize drag and drop
      setTimeout(() => {
        this.initializeDragAndDrop();
      }, 50);
    }
  }

  // Initialize the application
  const imageManager = new ImageManager();
  
  // Make it globally accessible for HTML onclick handlers
  window.imageManager = imageManager;
</script>
